const float pi = 3.14159265;

const int lineNumber = 32;

struct sRay
{
    vec2 origin;
    vec2 direction;
};

struct sLineSegment
{
    vec2 start;
    vec2 end;
    int channel;
    bool hit;
    float t;
    float height;
};
    
struct sPlane
{
    vec3 point;
    vec3 normal;
};

struct sView
{
    sRay PlayerRay;
    sRay currRay;
    float cameraAngle;
    float fov;
    float wallHeight;
    sLineSegment closestWall;
    vec4 wallColor;
    vec2 uv;
    float perspLen;
    float lensLen;
    
    vec4 skyColor;
    vec4 groundColor;
    
};
    
    
    

    


sView initView(float wallHeight)
{
    sView view;
    view.wallHeight = wallHeight;
    
    return view;
}



sLineSegment initLine(vec2 start, vec2 end, int channel)
{
    sLineSegment line;
    line.start = start;
    line.end = end;
    line.channel = channel;
    return line;
}

sLineSegment initLine(vec2 start, vec2 end)
{
    return initLine(start, end, 0);
}

float toRad(in vec2 direction)
{
    return atan(direction.x/direction.y);
}

float angleToUV(in float rad)
{
    return rad/(2.0 * 3.141592);
}



//Sets the ray direction to a normalized vector
//Direction has a range of -1.0 to 1.0 in each axis
sRay initRayRads(in vec2 origin, in float rad)
{
    sRay ray;
    ray.origin = origin;
    ray.direction = vec2(cos(rad),sin(rad));
    return ray;
}

sRay initRayUV(in vec2 origin, in vec2 uv)
{
    sRay ray;
    float twoPi = 6.28318;
    float rad = twoPi * uv.x;
    return initRayRads(origin, rad);
}

//Multiply result by whatever color to display
//Displays the distance from 0(closest) to 1(furthest)
vec4 setDistance(in sView v)
{
    bool visible = abs(2.0 * v.uv.y - 1.0) < v.closestWall.height;//abs(0.5 - uv.y) < (dist)/2.0);
    
    vec4 backgroundColor = (v.uv.y > 0.5) ? v.skyColor : v.groundColor;
    
    return visible ? v.wallColor * (1.0/v.closestWall.height*v.closestWall.height) : backgroundColor;
}

vec2 angToVec(float rad)
{
    return vec2
        (
            cos(rad),
            sin(rad)
        );
}

float angleOf(vec2 direction)
{
    float angle = atan(direction.x/direction.y);
    if(direction.y < 0.0)
    {
        angle += pi;
    }
    return angle;
}

float intersection(out sView v, out sLineSegment line)
{
    //Change to math using planes
    //https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection
    float x1 = line.start.x;
    float x2 = line.end.x;
    float y1 = line.start.y;
    float y2 = line.end.y;
    
    float x3 = v.currRay.origin.x;
    float x4 = v.currRay.origin.x + v.currRay.direction.x;
    float y3 = v.currRay.origin.y;
    float y4 = v.currRay.origin.y + v.currRay.direction.y;
    
    float denRecip = 1.0 / ((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4));
    
    float t =        ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) * denRecip;
    float u = -1.0 * ((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) * denRecip;
    
    bool tintersect = t > 0.0 && t < 1.0;
    bool uintersect = u > 0.0;
    
    line.t = t;
    
    vec2 intersectPoint = vec2(x1 + t * (x2 - x1), y1 + t * (y2 - y1));
    float dist = distance(v.currRay.origin, intersectPoint);
    float a = -angleOf(v.currRay.direction) + angleOf(v.PlayerRay.direction);
    dist *= cos(a);
    dist -= v.perspLen;
    
    line.hit = tintersect && uintersect;
    
    return dist;
    
    
    //https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_plane   
}

vec4 setChannel(in sView v)
{
    int channel = v.closestWall.channel;
    if(channel == 0)
    {
        return texture(iChannel0, vec2(v.closestWall.t*distance(v.closestWall.start, v.closestWall.end),(v.uv.y - 0.5)/v.closestWall.height + 0.5)) * vec4(0.796, 0.360, 0.819,1.0);
    }
    else if(channel == 1)
    {
        return texture(iChannel1, vec2(v.closestWall.t*distance(v.closestWall.start, v.closestWall.end),(v.uv.y - 0.5)/v.closestWall.height + 0.5))* vec4(0.211, 0.698, 0.968,1.0);
    }
    else if(channel == 2)
    {
        return texture(iChannel2, vec2(v.closestWall.t*distance(v.closestWall.start, v.closestWall.end),(v.uv.y - 0.5)/v.closestWall.height + 0.5));
    }
    else if(channel == 3)
    {
        return texture(iChannel3, vec2(v.closestWall.t*distance(v.closestWall.start, v.closestWall.end),(v.uv.y - 0.5)/v.closestWall.height + 0.5));
    }
    else
    {
        return texture(iChannel0, vec2(v.closestWall.t*distance(v.closestWall.start, v.closestWall.end),(v.uv.y - 0.5)/v.closestWall.height + 0.5));
    }
}

vec4 setScene(out sView v, in sLineSegment lines[lineNumber])
{
    v.closestWall.height = 0.0;
    for(int i = 0; i < lineNumber; i++)
    {
        lines[i].height = v.wallHeight/(intersection(v,lines[i]) + 1.0);
        if(lines[i].height > v.closestWall.height && lines[i].hit)
        {
            if(lines[i].channel == 3 && normalize(texture(iChannel3, vec2(lines[i].t*distance(lines[i].start, lines[i].end),(v.uv.y - 0.5)/lines[i].height + 0.5))).y > 0.5)
            {
                lines[i].hit = false;
            }
            else if(lines[i].channel == 2)
            {
                vec4 tex = texture(iChannel2, vec2(lines[i].t*distance(lines[i].start, lines[i].end),(v.uv.y - 0.5)/lines[i].height + 0.5));
                if(tex.x + tex.y + tex.z > 2.8)
                {
                    lines[i].hit = false;
                }
                else
            	{
             	   v.closestWall = lines[i];
            	}
                
            }
            else
            {
                v.closestWall = lines[i];
            }
            
        }
    }
    
    v.wallColor = setChannel(v);
    
    return setDistance(v);
    
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    //Make sure:
    
    //iChannel0 is set to Abstract 1
    //iChannel1 is set to Stars (On 3rd page of textures)
    
    //iChannel2 is set to Nyancat (On 2nd page of textures) and that the filter is set to nearest
    //iChannel3 is set to Claude Van Damme (In videos) and that the filter is also set to nearest
    
    
    
    /*
	Things I want to improve in the future:
	- Right now the code checks every single rectangle at every single moment. Maybe there's a way to see if the vertex is within the fov
	- There are still quite a few conditionals. I want to make sure that there are as few if statements as possible.
	- If there is a way to stop iterating so much, I would like to do that, as it would save a lot of time. 
	*/
    
    vec2 mouseUV = iMouse.xy / iResolution.xy;
    vec2 uv = fragCoord.xy/iResolution.xy;
    
    sView v = initView(1.0);
    v.uv = uv;
    float speed = 0.025;
    
    float moveDistance = 3.5;
    
    v.cameraAngle = (mouseUV.x + 0.5) * 4.0 * pi;
    v.PlayerRay = 
        initRayRads(
            vec2(
                cos(iTime * speed * 2.0 * pi) * moveDistance, //Equation for a line that goes around the environment
                sin(iTime * speed * 6.0 * pi) * moveDistance
                )
            ,v.cameraAngle
        );
    v.fov = radians(90.0);
    
    v.lensLen = 1.0;
    
    v.perspLen = v.lensLen/(2.0 *tan(v.fov));
    
    v.groundColor = mix(vec4(0.164, 0.031, 0.549,1.0), vec4(0.0,0.0,0.0,0.0),uv.y);
    v.skyColor = mix(texture(iChannel1, uv), vec4(0.643, 0.074, 0.803,1.0), 1.0-uv.y * 0.9);//mix(vec4(0.7, 0.9, 0.9, 1.0), vec4(0.9, 0.4, 0.1, 1.0), 1.0 - uv.y);
    
    v.currRay = initRayRads(v.PlayerRay.origin, (0.5 * v.fov) * (0.5 - uv.x) + v.cameraAngle);
    
    
    sLineSegment lines[lineNumber] = sLineSegment[lineNumber]
    (
        
        //Edges
        initLine(vec2(-4,4),vec2(4,4),0),
        initLine(vec2(4,4),vec2(4,-4),0),
        initLine(vec2(4,-4),vec2(-4,-4),0),
        initLine(vec2(-4,-4),vec2(-4,4),0),
        
        //Hallway
        initLine(vec2(-3,-2),vec2(-3,2),1),
        initLine(vec2(3,-2),vec2(3,2),1),
        
        //Along the hallway
        initLine(vec2(-3,1), vec2(-3.25,0),3),
        initLine(vec2(-3.25,0), vec2(-3,-1),3),
        initLine(vec2(3,1), vec2(3.25,0),3),
        initLine(vec2(3.25,0), vec2(3,-1),3),
        
        //Wedges
        initLine(vec2(-3,-4),      vec2(-1.75,-1.5),2),
        initLine(vec2(-1.75,-1.5), vec2(-1,-4),2),
        
        initLine(vec2(-3,4),       vec2(-1.75,1.5),2),
        initLine(vec2(-1.75,1.5),  vec2(-1,4),2),
        
        initLine(vec2(3,-4),       vec2(1.75,-1.5),2),
        initLine(vec2(1.75,-1.5),  vec2(1,-4),2),
        
        initLine(vec2(3,4),        vec2(1.75,1.5),2),
        initLine(vec2(1.75,1.5),   vec2(1,4),2),
        
        //Behind the wedges
        initLine(vec2(-2.5,-4),    vec2(-1.75,-2),1),
        initLine(vec2(-1.75,-2),   vec2(-1.5,-4),1),
        
        initLine(vec2(-2.5,4),     vec2(-1.75,2),1),
        initLine(vec2(-1.75,2),    vec2(-1.5,4),1),
        
        initLine(vec2(2.5,-4),     vec2(1.75,-2),1),
        initLine(vec2(1.75,-2),    vec2(1.5,-4),1),
        
        initLine(vec2(2.5,4),      vec2(1.75,2),1),
        initLine(vec2(1.75,2),     vec2(1.5,4),1),
        
        //Cross
        initLine(vec2(0,1), vec2(0,-1),1),
        initLine(vec2(1,0), vec2(-1,0),1),
        
        
        //Points
        //initLine(vec2(-0.5,-1.5), vec2(0,-2.5),3),
        //initLine(vec2(0,-2.5), vec2(0.5,-1.5),3),
        
        //initLine(vec2(0.5,1.5), vec2(0,2.5),3),
        //initLine(vec2(0,2.5), vec2(-0.5,1.5),3)
        
        initLine(vec2(0,0.5), vec2(0.5,0),3),
        initLine(vec2(0.5,0), vec2(0,-0.5),3),
        initLine(vec2(0,-0.5), vec2(-0.5,0),3),
        initLine(vec2(-0.5,0), vec2(0,0.5),3)
        
        
        
    );
    
    fragColor = setScene(v, lines);
}

