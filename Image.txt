struct sRay
{
    vec2 origin;
    vec2 direction;
};

struct sLineSegment
{
    vec2 start;
    vec2 end;
};
    
struct sPlane
{
    vec3 point;
    vec3 normal;
};

struct sView
{
    sRay playerDirection;
    float cameraAngle;
    float pov;
    float t;
    float maxDist;
    float closestWall;
    vec4 wallColor;
};

sView initView(float maxDist)
{
    sView view;
    view.maxDist = maxDist;
    view.closestWall = 0.0;
    return view;
}

sLineSegment initLine(vec2 start, vec2 end)
{
    sLineSegment line;
    line.start = start;
    line.end = end;
    return line;
}

float toRad(in vec2 direction)
{
    return atan(direction.x/direction.y);
}

float angleToUV(in float rad)
{
    return degrees(rad)/360.0;
}



//Sets the ray direction to a normalized vector
//Direction has a range of -1.0 to 1.0 in each axis
sRay initRayRads(in vec2 origin, in float rad)
{
    sRay ray;
    ray.origin = origin;
    ray.direction = vec2(cos(rad),sin(rad));
    return ray;
}

sRay initRayUV(in vec2 origin, in vec2 uv)
{
    sRay ray;
    float twoPi = 6.28318;
    float rad = twoPi * uv.x;
    return initRayRads(origin, rad);
}

//Multiply result by whatever color to display
//Displays the distance from 0(closest) to 1(furthest)
vec4 setDistance(in vec2 uv, in float distance)
{
    float visible = float(abs(0.5 - uv.y) < (distance)/2.0);
    
    return (distance) * vec4(visible,visible,visible,1.0);
}

float intersection(in sRay ray, out sView view, in sLineSegment line)
{
    //Change to math using planes
    //https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection
    float x1 = line.start.x;
    float x2 = line.end.x;
    float y1 = line.start.y;
    float y2 = line.end.y;
    
    float x3 = ray.origin.x;
    float x4 = ray.origin.x + ray.direction.x;
    float y3 = ray.origin.y;
    float y4 = ray.origin.y + ray.direction.y;
    
    float denRecip = 1.0 / ((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4));
    
    float t =        ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) * denRecip;
    float u = -1.0 * ((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) * denRecip;
    
    bool tintersect = t > 0.0 && t < 1.0;
    bool uintersect = u > 0.0;
    
    view.t = t;
    
    vec2 intersectPoint = vec2(x1 + t * (x2 - x1), y1 + t * (y2 - y1));
    
    float dist = (tintersect && uintersect) ? distance(ray.origin, intersectPoint) : 10.0;
    
    dist *= dot(view.playerDirection.direction,ray.direction);
    
    return dist;
    //https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_plane
    
        
}



bool addWall(out sView view, in sRay ray, in sLineSegment line)
{
    float intersec = (-1.0/view.maxDist)*intersection(ray,view,line) + 1.0;
    if(intersec > view.closestWall)
    {
        view.closestWall = intersec;
        return true;
    }
    else
    {
        return false;
    }
    
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    const float pi = 3.14159265358;
    vec2 mouseUV = iMouse.xy / iResolution.xy;
    vec2 uv = fragCoord.xy/iResolution.xy;
    
    sView view = initView(6.0);
    
    view.cameraAngle = (mouseUV.x) * 2.0 * pi;
    view.playerDirection = initRayRads(vec2(iTime/10.0),view.cameraAngle);
    view.pov = radians(90.0);
    
    //sRay ray = initRayRads(view.playerDirection.origin, view.pov * (0.5 - uv.x) + view.cameraAngle);
    
    //https://lodev.org/cgtutor/raycasting.html
    
    sRay cameraPlane;
    
    float camDist = 5.0;
    
    //Using trig; refer to website
    float planeLength = (2 * camDist)/tan((pi - pov)/2.0);
    
    cameraPlane.origin = playerDirection.origin + (playerDirection * camDist);
    cameraPlane.direction = playerDirection;
    
    
    
    
    
    
    
    
    
    fragColor = setDistance(uv,view.closestWall) * view.wallColor;//vec4(intersec,intersec,intersec,1.0);
}

