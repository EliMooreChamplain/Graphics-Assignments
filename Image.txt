//Eli Moore
//Midterm Project
//2D raycaster
//Image tab
//Resources I used:
//Guide on raycasting:
//https://lodev.org/cgtutor/raycasting.html
//Equations for calculations:
//https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection
//https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_plane   


const int lineNumber = 36;

//Multiply result by whatever color to display
//Displays the distance from 0(closest) to 1(furthest)
vec4 setDistance(in sView v)
{
    bool visible = abs(2.0 * v.uv.y - 1.0) < v.closestWall.height;//abs(0.5 - uv.y) < (dist)/2.0);
    
    vec4 backgroundColor = (v.uv.y > 0.5) ? v.skyColor : v.groundColor;
    
    return visible ? v.wallColor * (1.0/v.closestWall.height*v.closestWall.height) : backgroundColor;
}

float intersection(out sView v, out sLineSegment line)
{
    //Change to math using planes
    
    float x1 = line.start.x;
    float x2 = line.end.x;
    float y1 = line.start.y;
    float y2 = line.end.y;
    
    float x3 = v.currRay.origin.x;
    float x4 = v.currRay.origin.x + v.currRay.direction.x;
    float y3 = v.currRay.origin.y;
    float y4 = v.currRay.origin.y + v.currRay.direction.y;
    
    float denRecip = 1.0 / ((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4));
    
    float t =        ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) * denRecip;
    float u = -1.0 * ((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) * denRecip;
    
    bool tintersect = t > 0.0 && t < 1.0;
    bool uintersect = u > 0.0;
    
    line.t = t;
    
    vec2 intersectPoint = vec2(x1 + t * (x2 - x1), y1 + t * (y2 - y1));
    float dist = distance(v.currRay.origin, intersectPoint);
    float a = -angleOf(v.currRay.direction) + angleOf(v.PlayerRay.direction);
    dist *= cos(a);
    dist -= v.perspLen;
    
    line.hit = tintersect && uintersect;
    
    return dist;
    
    
    
}

vec4 setChannel(in sView v)
{
    int channel = v.closestWall.channel;
    if(channel == 0)
    {
        return texture(iChannel0, vec2(v.closestWall.t*distance(v.closestWall.start, v.closestWall.end),(v.uv.y - 0.5)/v.closestWall.height + 0.5)) * vec4(0.796, 0.360, 0.819,1.0);
    }
    else if(channel == 1)
    {
        return texture(iChannel1, vec2(v.closestWall.t*distance(v.closestWall.start, v.closestWall.end),(v.uv.y - 0.5)/v.closestWall.height + 0.5))* vec4(0.211, 0.698, 0.968,1.0);
    }
    else if(channel == 2)
    {
        return texture(iChannel2, vec2(v.closestWall.t*distance(v.closestWall.start, v.closestWall.end),(v.uv.y - 0.5)/v.closestWall.height + 0.5));
    }
    else if(channel == 3)
    {
        return texture(iChannel3, vec2(v.closestWall.t*distance(v.closestWall.start, v.closestWall.end),(v.uv.y - 0.5)/v.closestWall.height + 0.5));
    }
    else
    {
        return texture(iChannel0, vec2(v.closestWall.t*distance(v.closestWall.start, v.closestWall.end),(v.uv.y - 0.5)/v.closestWall.height + 0.5));
    }
}

vec4 setScene(out sView v, in sLineSegment lines[lineNumber])
{
    v.closestWall.height = 0.0;
    for(int i = 0; i < lineNumber; i++)
    {
        lines[i].height = v.wallHeight/(intersection(v,lines[i]) + 1.0);
        if(lines[i].height > v.closestWall.height && lines[i].hit)
        {
            
            //Specific cases for greenscreen
            if(lines[i].channel == 3 && normalize(texture(iChannel3, vec2(lines[i].t*distance(lines[i].start, lines[i].end),(v.uv.y - 0.5)/lines[i].height + 0.5))).y > 0.5)
            {//If too green
                lines[i].hit = false;
            }
            else if(lines[i].channel == 2)
            {
                vec4 tex = texture(iChannel2, vec2(lines[i].t*distance(lines[i].start, lines[i].end),(v.uv.y - 0.5)/lines[i].height + 0.5));
                if(tex.x + tex.y + tex.z > 2.8)
                {//If too white
                    lines[i].hit = false;
                }
                else
            	{
             	   v.closestWall = lines[i];
            	}
                
            }
            else
            {
                v.closestWall = lines[i];
            }
            
        }
    }
    
    v.wallColor = setChannel(v);
    
    return setDistance(v);
    
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    //Make sure:
    //iChannel0 is set to Organic 2
    //iChannel1 is set to Stars (On 3rd page of textures)
    //iChannel2 is set to Nyancat (On 2nd page of textures) and that the filter is set to nearest
    //iChannel3 is set to Claude Van Damme (In videos) and that the filter is also set to nearest
    
    
    
    /*
	Things I want to improve in the future:
	- Right now the code checks every single rectangle at every single moment. Maybe there's a way to see if the vertex is within the fov
	- There are still quite a few conditionals. I want to make sure that there are as few if statements as possible.
	- If there is a way to stop iterating so much, I would like to do that, as it would save a lot of time. 
	*/
    
    vec2 mouseUV = iMouse.xy / iResolution.xy;
    vec2 uv = fragCoord.xy/iResolution.xy;
    
    
    
    float speed = 0.025;
    float moveDistance = 3.5;
    
    sView v = initView(
        uv,//uv 
        (mouseUV.x + 0.5) * 4.0 * pi,//Camera Angle
        vec2(//Player Position
                cos(iTime * speed * 2.0 * pi) * moveDistance, //Equation for a line that goes around the environment
                sin(iTime * speed * 6.0 * pi) * moveDistance
                ),
        radians(90.0),//fov
        1.0,//Length of the camera plane
        1.0,//WallHeight
        mix(texture(iChannel1, uv), vec4(0.643, 0.074, 0.803,1.0), 1.0-uv.y * 0.9),//Sky Color 
        mix(vec4(0.164, 0.031, 0.549,1.0), vec4(0.0,0.0,0.0,0.0),uv.y)//Ground Color
    );
    
    sLineSegment lines[lineNumber] = sLineSegment[lineNumber]
    (
        
        //Edges
        initLine(vec2(-4,4),vec2(4,4),0),
        initLine(vec2(4,4),vec2(4,-4),0),
        initLine(vec2(4,-4),vec2(-4,-4),0),
        initLine(vec2(-4,-4),vec2(-4,4),0),
        
        //Hallway
        initLine(vec2(-3,-2),vec2(-3,2),1),
        initLine(vec2(3,-2),vec2(3,2),1),
        
        //Along the hallway
        initLine(vec2(-3,1), vec2(-3.25,0),3),
        initLine(vec2(-3.25,0), vec2(-3,-1),3),
        initLine(vec2(3,1), vec2(3.25,0),3),
        initLine(vec2(3.25,0), vec2(3,-1),3),
        
        //Wedges
        initLine(vec2(-3,-4),      vec2(-1.75,-1.5),2),
        initLine(vec2(-1.75,-1.5), vec2(-1,-4),2),
        
        initLine(vec2(-3,4),       vec2(-1.75,1.5),2),
        initLine(vec2(-1.75,1.5),  vec2(-1,4),2),
        
        initLine(vec2(3,-4),       vec2(1.75,-1.5),2),
        initLine(vec2(1.75,-1.5),  vec2(1,-4),2),
        
        initLine(vec2(3,4),        vec2(1.75,1.5),2),
        initLine(vec2(1.75,1.5),   vec2(1,4),2),
        
        //Behind the wedges
        initLine(vec2(-2.5,-4),    vec2(-1.75,-2),1),
        initLine(vec2(-1.75,-2),   vec2(-1.5,-4),1),
        
        initLine(vec2(-2.5,4),     vec2(-1.75,2),1),
        initLine(vec2(-1.75,2),    vec2(-1.5,4),1),
        
        initLine(vec2(2.5,-4),     vec2(1.75,-2),1),
        initLine(vec2(1.75,-2),    vec2(1.5,-4),1),
        
        initLine(vec2(2.5,4),      vec2(1.75,2),1),
        initLine(vec2(1.75,2),     vec2(1.5,4),1),
        
        //Cross
        initLine(vec2(0,1), vec2(0,-1),1),
        initLine(vec2(1,0), vec2(-1,0),1),
        
        
        //Points
        initLine(vec2(-0.5,-1.5), vec2(0,-2.5),2),
        initLine(vec2(0,-2.5), vec2(0.5,-1.5),2),
        
        initLine(vec2(0.5,1.5), vec2(0,2.5),2),
        initLine(vec2(0,2.5), vec2(-0.5,1.5),2),
        
        initLine(vec2(0,0.5), vec2(0.5,0),3),
        initLine(vec2(0.5,0), vec2(0,-0.5),3),
        initLine(vec2(0,-0.5), vec2(-0.5,0),3),
        initLine(vec2(-0.5,0), vec2(0,0.5),3)
    );
    
    fragColor = setScene(v, lines);
}

