struct sRay
{
    vec2 origin;
    vec2 direction;
};

struct sLineSegment
{
    vec2 start;
    vec2 end;
};
    
struct sPlane
{
    vec3 point;
    vec3 normal;
};

struct sView
{
    sRay cameraDirection;
    float cameraAngle;
    float pov;
    float t;
    float maxDist;
    float closestWall;
    vec4 wallColor;
};

sView initView(float maxDist)
{
    sView view;
    view.maxDist = maxDist;
    view.closestWall = 0.0;
    return view;
}

sLineSegment initLine(vec2 start, vec2 end)
{
    sLineSegment line;
    line.start = start;
    line.end = end;
    return line;
}

float toRad(in vec2 direction)
{
    return atan(direction.x/direction.y);
}

float angleToUV(in float rad)
{
    return degrees(rad)/360.0;
}



//Sets the ray direction to a normalized vector
//Direction has a range of -1.0 to 1.0 in each axis
sRay initRayRads(in vec2 origin, in float rad)
{
    sRay ray;
    ray.origin = origin;
    ray.direction = vec2(cos(rad),sin(rad));
    return ray;
}

sRay initRayUV(in vec2 origin, in vec2 uv)
{
    sRay ray;
    float twoPi = 6.28318;
    float rad = twoPi * uv.x;
    return initRayRads(origin, rad);
}

//Multiply result by whatever color to display
//Displays the distance from 0(closest) to 1(furthest)
vec4 setDistance(in vec2 uv, in float distance)
{
    float visible = float(abs(0.5 - uv.y) < (distance)/2.0);
    
    return (distance) * vec4(visible,visible,visible,1.0);
}

float intersection(in sRay ray, out sView view, in sLineSegment line)
{
    //Change to math using planes
    //https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection
    float x1 = line.start.x;
    float x2 = line.end.x;
    float y1 = line.start.y;
    float y2 = line.end.y;
    
    float x3 = ray.origin.x;
    float x4 = ray.origin.x + ray.direction.x;
    float y3 = ray.origin.y;
    float y4 = ray.origin.y + ray.direction.y;
    
    float denRecip = 1.0 / ((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4));
    
    float t =        ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) * denRecip;
    float u = -1.0 * ((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) * denRecip;
    
    bool tintersect = t > 0.0 && t < 1.0;
    bool uintersect = u > 0.0;
    
    view.t = t;
    
    vec2 intersectPoint = vec2(x1 + t * (x2 - x1), y1 + t * (y2 - y1));
    
    float dist = (tintersect && uintersect) ? distance(ray.origin, intersectPoint) : 10.0;
    
    dist *= dot(view.cameraDirection.direction,ray.direction);
    
    return dist;
    //https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_plane
    
        
}



bool addWall(out sView view, in sRay ray, in sLineSegment line)
{
    float intersec = (-1.0/view.maxDist)*intersection(ray,view,line) + 1.0;
    if(intersec > view.closestWall)
    {
        view.closestWall = intersec;
        return true;
    }
    else
    {
        return false;
    }
    
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 mouseUV = iMouse.xy / iResolution.xy;
    vec2 uv = fragCoord.xy/iResolution.xy;
    
    sView view = initView(6.0);
    
    view.cameraAngle = (mouseUV.x) * 6.283185;
    view.cameraDirection = initRayRads(vec2(iTime/10.0),view.cameraAngle);
    view.pov = radians(90.0);
    
    sRay ray = initRayRads(view.cameraDirection.origin, view.pov * (0.5 - uv.x) + view.cameraAngle);
    
    
    
    
    
    
    //sLineSegment line1 = initLine(vec2(1.0,1.0), vec2(1.0,4.0));
    //sLineSegment line2 = initLine(vec2(-2.0,-4.0), vec2(-2.5,-2.5));
    
    sLineSegment line0 = initLine(vec2(1.5,5), vec2(-2,1.5));
sLineSegment line1 = initLine(vec2(1.5,-1.5), vec2(1.5,1));
sLineSegment line2 = initLine(vec2(5.5,-6.5), vec2(3.5,3));
sLineSegment line3 = initLine(vec2(2,6.5), vec2(-7.5,7.5));
sLineSegment line4 = initLine(vec2(-4,-3), vec2(6,1.5));
sLineSegment line5 = initLine(vec2(-3,-1.5), vec2(-3,0));
sLineSegment line6 = initLine(vec2(-3.5,5), vec2(-7.5,0));
sLineSegment line7 = initLine(vec2(0.5,-6.5), vec2(-5.5,2));
sLineSegment line8 = initLine(vec2(6.5,0.5), vec2(3.5,0.5));
sLineSegment line9 = initLine(vec2(7,-2.5), vec2(-6.5,4.5));
    
    view.wallColor = vec4(0.0,0.0,0.0,0.0);
    
    if(addWall(view, ray, line0))
    {
        view.wallColor = texture(iChannel0, vec2(view.t,(0.5 - uv.y)/view.closestWall));
    }
    if(addWall(view, ray, line1))
    {
        view.wallColor = texture(iChannel0, vec2(view.t,(0.5 - uv.y)/view.closestWall));
    }
    if(addWall(view, ray, line2))
    {
        view.wallColor = texture(iChannel1, vec2(view.t,(0.5 - uv.y)/view.closestWall));
    }
    if(addWall(view, ray, line3))
    {
        view.wallColor = texture(iChannel0, vec2(view.t,(0.5 - uv.y)/view.closestWall));
    }
    if(addWall(view, ray, line4))
    {
        view.wallColor = texture(iChannel1, vec2(view.t,(0.5 - uv.y)/view.closestWall));
    }
    if(addWall(view, ray, line5))
    {
        view.wallColor = texture(iChannel0, vec2(view.t,(0.5 - uv.y)/view.closestWall));
    }
    if(addWall(view, ray, line6))
    {
        view.wallColor = texture(iChannel1, vec2(view.t,(0.5 - uv.y)/view.closestWall));
    }
    if(addWall(view, ray, line7))
    {
        view.wallColor = texture(iChannel0, vec2(view.t,(0.5 - uv.y)/view.closestWall));
    }
    if(addWall(view, ray, line8))
    {
        view.wallColor = texture(iChannel1, vec2(view.t,(0.5 - uv.y)/view.closestWall));
    }
    if(addWall(view, ray, line9))
    {
        view.wallColor = texture(iChannel0, vec2(view.t,(0.5 - uv.y)/view.closestWall));
    }
    //addWall(view, ray, line3);
    //addWall(view, ray, line4);
    //addWall(view, ray, line2);
    
    
    fragColor = setDistance(uv,view.closestWall) * view.wallColor;//vec4(intersec,intersec,intersec,1.0);
}

